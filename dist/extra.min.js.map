{"version":3,"sources":["../src/extra.js"],"names":["getPathValue","obj","path","field","split","len","length","i","value","_typeof","undef","getObjectPart","source","parts","partMap","Array","isArray","result","key","getFieldFilter","getPartFilter","isDifferentValue","state","prevState","deep","prevValue","unlike","isArrayState","isArrayPrevState","unlikeDeep","listen","store","listener","settings","handle","when","filter","filterType","_listate2","default"],"mappings":"yZA+CO,QAASA,GAAaC,EAAKC,GAM9B,IALA,GAAMC,GAAQD,EAAKE,MAAM,KACnBC,EAAMF,EAAMG,OACdC,EAAI,EACJC,EAAQP,EAELM,EAAIF,GAAOG,GAA0B,gBAAjB,KAAOA,EAAP,YAAAC,EAAOD,KAC9BA,EAAQA,EAAML,EAAMI,KAGxB,OAAOA,GAAIF,MALPK,GAOMF,EA2CP,QAASG,GAAcC,EAAQC,GAClC,GAAIC,OAAAA,EACJ,IAAqB,gBAAVD,GACPC,EAAAA,KAAYD,EAAQA,OAEnB,IAAIE,MAAMC,QAAQH,GAAQ,CAC3BC,IACA,KAAK,GAAIP,GAAI,EAAGF,EAAMQ,EAAMP,OAAQC,EAAIF,EAAKE,IACzCO,EAAQD,EAAMN,IAAMM,EAAMN,OAI9BO,GAAUD,CAGd,IAAMI,KACN,KAAK,GAAMC,KAAOJ,GACdG,EAAOC,GAAOlB,EAAaY,EAAQE,EAAQI,GAG/C,OAAOD,GA6BJ,QAASE,GAAejB,GAC3B,MAAO,UAACD,GAAD,MAASD,GAAaC,EAAKC,IAoC/B,QAASkB,GAAcP,GAC1B,MAAO,UAACZ,GAAD,MAASU,GAAcV,EAAKY,IAIvC,QAASQ,GAAiBC,EAAOC,EAAWpB,EAAOqB,GAC/C,GAAMhB,GAAQc,EAAMnB,GACdsB,EAAYF,EAAUpB,EAE5B,OAAOK,KAAUiB,KACHD,GAAQE,EAAOlB,EAAOiB,EAAWD,IAwB5C,QAASE,GAAOJ,EAAOC,EAAWC,GACrC,GAAIF,GAASC,GAA8B,gBAAjB,KAAOD,EAAP,YAAAb,EAAOa,KAA2C,gBAArB,KAAOC,EAAP,YAAAd,EAAOc,IAAwB,CAClF,GAAMI,GAAeZ,MAAMC,QAAQM,GAC7BM,EAAmBb,MAAMC,QAAQO,EACvC,IAAII,GAAgBC,EAAkB,CAClC,GAAMvB,GAAMiB,EAAMhB,MAClB,IAAID,IAAQkB,EAAUjB,OAQlB,OAAO,CAPP,KAAK,GAAIC,GAAI,EAAGA,EAAIF,EAAKE,IACrB,GAAIc,EAAiBC,EAAOC,EAAWhB,EAAGiB,GACtC,OAAO,MAQlB,CAAA,GAAIG,GAAgBC,EACrB,OAAO,CAGP,IAAIV,OAAAA,EACJ,KAAKA,IAAOI,GACR,KAAOJ,IAAOK,KAAcF,EAAiBC,EAAOC,EAAWL,EAAKM,GAChE,OAAO,CAGf,KAAKN,IAAOK,GACR,KAAOL,IAAOI,IACV,OAAO,EAKnB,OAAO,EAGX,MAAOA,KAAUC,EAiBd,QAASM,GAAWP,EAAOC,GAC9B,MAAOG,GAAOJ,EAAOC,GAAW,GA2BrB,QAASO,GAAOC,EAAOC,GAClC,GAAIC,OAAAA,EACJ,IAAwB,kBAAbD,GACPC,GAAYC,OAAQF,OAEnB,CACDC,IACA,KAAK,GAAMf,KAAOc,GACdC,EAASf,GAAOc,EAASd,GAG3Be,EAASE,OACXF,EAASE,KAAOT,EAZwB,IAcpCU,GAAWH,EAAXG,MACR,IAAIA,EAAQ,CACR,GAAMC,OAAA,KAAoBD,EAApB,YAAA3B,EAAoB2B,EACP,YAAfC,EACAJ,EAASG,OAAShB,EAAcgB,GAEZ,WAAfC,IACLJ,EAASG,OAASjB,EAAeiB,IAIzC,OAAO,EAAAE,EAAAC,SAAWR,EAAOE,qCA1RbjC,aAAAA,IAuDAW,cAAAA,IAiDAQ,eAAAA,IAqCAC,cAAAA,IAkCAM,OAAAA,IAsDAG,WAAAA,YA4BQC,2QA4BfA,OAAAA","sourcesContent":["/*\r\n * listate\r\n * https://github.com/gamtiq/listate\r\n *\r\n * Copyright (c) 2017 Denis Sikuler\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * Library for listening on changes of Redux store state.\r\n * \r\n * @module listate/extra\r\n */\r\n\r\nimport baseListen from './listate';\r\n\r\n/**\r\n * Return value of specified field path inside given object.\r\n *\r\n * @example\r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value'\r\n *         },\r\n *         d: true\r\n *     },\r\n *     e: 4,\r\n *     f: [1, 'z', null]\r\n * };\r\n *\r\n * getPathValue(obj, 'a.b.c');   // 'value'\r\n * getPathValue(obj, 'a.d');   // true\r\n * getPathValue(obj, 'e');   // 4\r\n * getPathValue(obj, 'f.1');   // 'z'\r\n * getPathValue(obj, 'g');   // undefined\r\n * getPathValue(obj, 'a.c');   // undefined\r\n * getPathValue(obj, 'e.a');   // undefined\r\n * getPathValue(obj, 'f.8');   // undefined\r\n *\r\n * @param {object} obj\r\n *      The object to traverse.\r\n * @param {string} path\r\n *      Dot-delimited path to a field whose value should be returned.\r\n * @return {any}\r\n *      Value of the field or `undefined` when the field is not found inside the object.\r\n */\r\nexport function getPathValue(obj, path) {\r\n    const field = path.split('.');\r\n    const len = field.length;\r\n    let i = 0;\r\n    let value = obj;\r\n    let undef;\r\n    while (i < len && value && typeof value === 'object') {\r\n        value = value[field[i++]];\r\n    }\r\n\r\n    return i < len\r\n            ? undef\r\n            : value;\r\n}\r\n\r\n/**\r\n * Create an object containing specified parts of the given object.\r\n *\r\n * @example\r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value',\r\n *            d: true\r\n *         },\r\n *         e: 4,\r\n *         f: [1, 'z', null]\r\n *     },\r\n *     g: 7,\r\n *     h: {\r\n *         i: false,\r\n *         j: 0\r\n *     },\r\n *     k: 'king',\r\n *     l: 'last'\r\n * };\r\n *\r\n * getObjectPart(obj, {f1: 'a.b.d', f2: 'a.f.1', f3: 'g', f4: 'h.j'});   // {f1: true, f2: 'z', f3: 7, f4: 0}\r\n * getObjectPart(obj, ['k', 'l']);   // {k: 'king', l: 'last'}\r\n * getObjectPart(obj, 'g');   // {g: 7}\r\n *\r\n * @param {object} source\r\n *      A source object that should be processed.\r\n * @param {array | object | string} parts\r\n *      Specifies which parts of the source object should be extracted.\r\n *      Parts are described as an object of the following form:\r\n *      `{resultField1: 'path.to.source.part1', resultField2: 'path.to.part2', ...}`.\r\n *      Each field of the object is a property name of resulting object\r\n *      whose value is the value of specified source object part.  \r\n *      String value `'field'` is equal to `{field: 'field'}`.  \r\n *      Array value `['a', 'b', 'c', ...]` is equal to `{a: 'a', b: 'b', c: 'c', ...}`.\r\n * @return {object}\r\n *      Object that contains the extracted parts of the source object.\r\n * @see {@link module:listate/extra.getPathValue getPathValue}\r\n */\r\nexport function getObjectPart(source, parts) {\r\n    let partMap;\r\n    if (typeof parts === 'string') {\r\n        partMap = {[parts]: parts};\r\n    }\r\n    else if (Array.isArray(parts)) {\r\n        partMap = {};\r\n        for (let i = 0, len = parts.length; i < len; i++) {\r\n            partMap[parts[i]] = parts[i];\r\n        }\r\n    }\r\n    else {\r\n        partMap = parts;\r\n    }\r\n\r\n    const result = {};\r\n    for (const key in partMap) {\r\n        result[key] = getPathValue(source, partMap[key]);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Return a function that extracts value of the specified field path inside a given object.\r\n *\r\n * @example\r\n * const filter = getFieldFilter('a.d');\r\n * \r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value'\r\n *         },\r\n *         d: 17\r\n *     },\r\n *     e: 4,\r\n *     f: [1, 'z', null]\r\n * };\r\n *\r\n * filter(obj);   // 17\r\n * filter({a: 1, b: 2});   // undefined\r\n *\r\n * @param {string} path\r\n *      Dot-delimited path to a field whose value should be extracted.\r\n * @return {Function}\r\n *      A function that extracts value of the specified field path inside a given object.\r\n * @see {@link module:listate/extra.getPathValue getPathValue}\r\n */\r\nexport function getFieldFilter(path) {\r\n    return (obj) => getPathValue(obj, path);\r\n}\r\n\r\n/**\r\n * Return a function that creates an object containing the specified parts of a given object.\r\n *\r\n * @example\r\n * const filter = getPartFilter({f1: 'a.b.c', f2: 'h.j', f3: 'k'});\r\n * \r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value',\r\n *            d: true\r\n *         },\r\n *         e: 4,\r\n *         f: [1, 'z', null]\r\n *     },\r\n *     g: 7,\r\n *     h: {\r\n *         i: false,\r\n *         j: 0\r\n *     },\r\n *     k: 'king',\r\n *     l: 'last'\r\n * };\r\n *\r\n * filter(obj);   // {f1: 'value', f2: 0, f3: 'king'}\r\n * filter({a: 1, b: 2, k: 73});   // {f1: undefined, f2: undefined, f3: 73}\r\n *\r\n * @param {array | object | string} parts\r\n *      Specifies which parts should be extracted (see {@link module:listate/extra.getObjectPart getObjectPart}).\r\n * @return {Function}\r\n *      A function that creates an object containing the specified parts of a given object.\r\n * @see {@link module:listate/extra.getObjectPart getObjectPart}\r\n */\r\nexport function getPartFilter(parts) {\r\n    return (obj) => getObjectPart(obj, parts);\r\n}\r\n\r\n// eslint-disable-next-line max-params, require-jsdoc\r\nfunction isDifferentValue(state, prevState, field, deep) {\r\n    const value = state[field];\r\n    const prevValue = prevState[field];\r\n\r\n    return value !== prevValue\r\n            && (! deep || unlike(value, prevValue, deep));   // eslint-disable-line no-use-before-define\r\n}\r\n\r\n/**\r\n * Check whether current object (state) is not equal previous object (state)\r\n * comparing values of their fields.\r\n *\r\n * @example\r\n * unlike({a: 1}, {a: 2});   // true\r\n * unlike({a: 1, b: 2}, {a: 1});   // true\r\n * unlike({a: 1, b: 2}, {a: 1, b: 2});   // false\r\n * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}});   // true\r\n * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}, true);   // false\r\n *\r\n * @param {object} state\r\n *      A current object (state).\r\n * @param {object} prevState\r\n *      A previous object (state).\r\n * @param {boolean} [deep=false]\r\n *      When `true` recursively calls the function to compare fields having object values.\r\n *      By default shallow equality comparison (`!==`) is used.\r\n * @return {boolean}\r\n *      `true` if current object is not equal previous object.\r\n */\r\nexport function unlike(state, prevState, deep) {\r\n    if (state && prevState && typeof state === 'object' && typeof prevState === 'object') {\r\n        const isArrayState = Array.isArray(state);\r\n        const isArrayPrevState = Array.isArray(prevState);\r\n        if (isArrayState && isArrayPrevState) {\r\n            const len = state.length;\r\n            if (len === prevState.length) {\r\n                for (let i = 0; i < len; i++) {\r\n                    if (isDifferentValue(state, prevState, i, deep)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else if (isArrayState || isArrayPrevState) {\r\n            return true;\r\n        }\r\n        else {\r\n            let key;\r\n            for (key in state) {\r\n                if (! (key in prevState) || isDifferentValue(state, prevState, key, deep)) {\r\n                    return true;\r\n                }\r\n            }\r\n            for (key in prevState) {\r\n                if (! (key in state)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return state !== prevState;\r\n}\r\n\r\n/**\r\n * Check whether current object (state) is not equal previous object (state)\r\n * deeply comparing values of their fields.\r\n *\r\n * The same as `{@link module:listate/extra.unlike unlike}(state, prevState, true)`.\r\n *\r\n * @param {object} state\r\n *      A current object (state).\r\n * @param {object} prevState\r\n *      A previous object (state).\r\n * @return {boolean}\r\n *      `true` if current object is not equal previous object.\r\n * @see {@link module:listate/extra.unlike unlike}\r\n */\r\nexport function unlikeDeep(state, prevState) {\r\n    return unlike(state, prevState, true);\r\n}\r\n\r\n/**\r\n * Add/register state change listener for the given store.\r\n *\r\n * It is a wrap around {@link module:listate.listen listate.listen} that supports enhanced listener settings.\r\n *\r\n * @param {module:listate~Store} store\r\n *      Store for which listener should be added/registered.\r\n * @param {Function | object} listener\r\n *      Specifies listener that should be called on a state change.\r\n *      Can be a function or an object that defines listener settings/details.\r\n *      Settings are the same as for {@link module:listate.listate listate.listate} with the following exceptions.\r\n * @param {Array | Function | object | string} [listener.filter=(state) => state]\r\n *      Specifies which state part will be used inside `when` to determine\r\n *      whether the listener should be called.\r\n *      When an array or an object is passed, the used filter will be result of\r\n *      {@link module:listate/extra.getPartFilter getPartFilter(listener.filter)}.\r\n *      When a string is passed, the used filter will be result of\r\n *      {@link module:listate/extra.getFieldFilter getFieldFilter(listener.filter)}.\r\n * @param {Function} [listener.when=unlike]\r\n *      Function to determine whether the listener should be called.\r\n *      By default {@link module:listate/extra.unlike unlike} is used.\r\n * @return {Function}\r\n *      A function that removes/unsubscribes the listener.\r\n */\r\nexport default function listen(store, listener) {\r\n    let settings;\r\n    if (typeof listener === 'function') {\r\n        settings = {handle: listener};\r\n    }\r\n    else {\r\n        settings = {};\r\n        for (const key in listener) {\r\n            settings[key] = listener[key];\r\n        }\r\n    }\r\n    if (! settings.when) {\r\n        settings.when = unlike;\r\n    }\r\n    const { filter } = settings;\r\n    if (filter) {\r\n        const filterType = typeof filter;\r\n        if (filterType === 'object') {\r\n            settings.filter = getPartFilter(filter);\r\n        }\r\n        else if (filterType === 'string') {\r\n            settings.filter = getFieldFilter(filter);\r\n        }\r\n    }\r\n\r\n    return baseListen(store, settings);\r\n}\r\n\r\nexport { listen };\r\n"]}