{"version":3,"sources":["../../src/extra.js"],"names":["getPathValue","getObjectPart","getFieldFilter","getPartFilter","unlike","unlikeDeep","listen","obj","path","field","split","len","length","i","value","undef","source","parts","partMap","Array","isArray","result","key","isDifferentValue","state","prevState","deep","prevValue","isArrayState","isArrayPrevState","store","listener","settings","handle","when","filter","filterType"],"mappings":"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","file":"extra.js","sourcesContent":["/*\r\n * listate\r\n * https://github.com/gamtiq/listate\r\n *\r\n * Copyright (c) 2017-2019 Denis Sikuler\r\n * Licensed under the MIT license.\r\n */\r\n\r\n/**\r\n * Library for listening on changes of Redux store state.\r\n * \r\n * @module listate/extra\r\n */\r\n\r\nimport baseListen from './listate';\r\n\r\n/**\r\n * Return value of specified field path inside given object.\r\n *\r\n * @example\r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value'\r\n *         },\r\n *         d: true\r\n *     },\r\n *     e: 4,\r\n *     f: [1, 'z', null]\r\n * };\r\n *\r\n * getPathValue(obj, 'a.b.c');   // 'value'\r\n * getPathValue(obj, 'a.d');   // true\r\n * getPathValue(obj, 'e');   // 4\r\n * getPathValue(obj, 'f.1');   // 'z'\r\n * getPathValue(obj, 'g');   // undefined\r\n * getPathValue(obj, 'a.c');   // undefined\r\n * getPathValue(obj, 'e.a');   // undefined\r\n * getPathValue(obj, 'f.8');   // undefined\r\n *\r\n * @param {object} obj\r\n *      The object to traverse.\r\n * @param {string} path\r\n *      Dot-delimited path to a field whose value should be returned.\r\n * @return {any}\r\n *      Value of the field or `undefined` when the field is not found inside the object.\r\n */\r\nexport function getPathValue(obj, path) {\r\n    const field = path.split('.');\r\n    const len = field.length;\r\n    let i = 0;\r\n    let value = obj;\r\n    let undef;\r\n    while (i < len && value && typeof value === 'object') {\r\n        value = value[field[i++]];\r\n    }\r\n\r\n    return i < len\r\n        ? undef\r\n        : value;\r\n}\r\n\r\n/**\r\n * Create an object containing specified parts of the given object.\r\n *\r\n * @example\r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value',\r\n *            d: true\r\n *         },\r\n *         e: 4,\r\n *         f: [1, 'z', null]\r\n *     },\r\n *     g: 7,\r\n *     h: {\r\n *         i: false,\r\n *         j: 0\r\n *     },\r\n *     k: 'king',\r\n *     l: 'last'\r\n * };\r\n *\r\n * getObjectPart(obj, {f1: 'a.b.d', f2: 'a.f.1', f3: 'g', f4: 'h.j'});   // {f1: true, f2: 'z', f3: 7, f4: 0}\r\n * getObjectPart(obj, ['k', 'l']);   // {k: 'king', l: 'last'}\r\n * getObjectPart(obj, 'g');   // {g: 7}\r\n *\r\n * @param {object} source\r\n *      A source object that should be processed.\r\n * @param {array | object | string} parts\r\n *      Specifies which parts of the source object should be extracted.\r\n *      Parts are described as an object of the following form:\r\n *      `{resultField1: 'path.to.source.part1', resultField2: 'path.to.part2', ...}`.\r\n *      Each field of the object is a property name of resulting object\r\n *      whose value is the value of specified source object part.  \r\n *      String value `'field'` is equal to `{field: 'field'}`.  \r\n *      Array value `['a', 'b', 'c', ...]` is equal to `{a: 'a', b: 'b', c: 'c', ...}`.\r\n * @return {object}\r\n *      Object that contains the extracted parts of the source object.\r\n * @see {@link module:listate/extra.getPathValue getPathValue}\r\n */\r\nexport function getObjectPart(source, parts) {\r\n    let partMap;\r\n    if (typeof parts === 'string') {\r\n        partMap = {[parts]: parts};\r\n    }\r\n    else if (Array.isArray(parts)) {\r\n        partMap = {};\r\n        for (let i = 0, len = parts.length; i < len; i++) {\r\n            partMap[parts[i]] = parts[i];\r\n        }\r\n    }\r\n    else {\r\n        partMap = parts;\r\n    }\r\n\r\n    const result = {};\r\n    for (const key in partMap) {\r\n        result[key] = getPathValue(source, partMap[key]);\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Return a function that extracts value of the specified field path inside a given object.\r\n *\r\n * @example\r\n * const filter = getFieldFilter('a.d');\r\n * \r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value'\r\n *         },\r\n *         d: 17\r\n *     },\r\n *     e: 4,\r\n *     f: [1, 'z', null]\r\n * };\r\n *\r\n * filter(obj);   // 17\r\n * filter({a: 1, b: 2});   // undefined\r\n *\r\n * @param {string} path\r\n *      Dot-delimited path to a field whose value should be extracted.\r\n * @return {Function}\r\n *      A function that extracts value of the specified field path inside a given object.\r\n * @see {@link module:listate/extra.getPathValue getPathValue}\r\n */\r\nexport function getFieldFilter(path) {\r\n    return (obj) => getPathValue(obj, path);\r\n}\r\n\r\n/**\r\n * Return a function that creates an object containing the specified parts of a given object.\r\n *\r\n * @example\r\n * const filter = getPartFilter({f1: 'a.b.c', f2: 'h.j', f3: 'k'});\r\n * \r\n * const obj = {\r\n *     a: {\r\n *         b: {\r\n *            c: 'value',\r\n *            d: true\r\n *         },\r\n *         e: 4,\r\n *         f: [1, 'z', null]\r\n *     },\r\n *     g: 7,\r\n *     h: {\r\n *         i: false,\r\n *         j: 0\r\n *     },\r\n *     k: 'king',\r\n *     l: 'last'\r\n * };\r\n *\r\n * filter(obj);   // {f1: 'value', f2: 0, f3: 'king'}\r\n * filter({a: 1, b: 2, k: 73});   // {f1: undefined, f2: undefined, f3: 73}\r\n *\r\n * @param {array | object | string} parts\r\n *      Specifies which parts should be extracted (see {@link module:listate/extra.getObjectPart getObjectPart}).\r\n * @return {Function}\r\n *      A function that creates an object containing the specified parts of a given object.\r\n * @see {@link module:listate/extra.getObjectPart getObjectPart}\r\n */\r\nexport function getPartFilter(parts) {\r\n    return (obj) => getObjectPart(obj, parts);\r\n}\r\n\r\n// eslint-disable-next-line max-params, require-jsdoc\r\nfunction isDifferentValue(state, prevState, field, deep) {\r\n    const value = state[field];\r\n    const prevValue = prevState[field];\r\n\r\n    return value !== prevValue\r\n            && (! deep || unlike(value, prevValue, deep));   // eslint-disable-line no-use-before-define\r\n}\r\n\r\n/**\r\n * Check whether current object (state) is not equal previous object (state)\r\n * comparing values of their fields.\r\n *\r\n * @example\r\n * unlike({a: 1}, {a: 2});   // true\r\n * unlike({a: 1, b: 2}, {a: 1});   // true\r\n * unlike({a: 1, b: 2}, {a: 1, b: 2});   // false\r\n * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}});   // true\r\n * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}, true);   // false\r\n *\r\n * @param {object} state\r\n *      A current object (state).\r\n * @param {object} prevState\r\n *      A previous object (state).\r\n * @param {boolean} [deep=false]\r\n *      When `true` recursively calls the function to compare fields having object values.\r\n *      By default shallow equality comparison (`!==`) is used.\r\n * @return {boolean}\r\n *      `true` if current object is not equal previous object.\r\n */\r\nexport function unlike(state, prevState, deep) {\r\n    if (state && prevState && typeof state === 'object' && typeof prevState === 'object') {\r\n        const isArrayState = Array.isArray(state);\r\n        const isArrayPrevState = Array.isArray(prevState);\r\n        if (isArrayState && isArrayPrevState) {\r\n            const len = state.length;\r\n            if (len === prevState.length) {\r\n                for (let i = 0; i < len; i++) {\r\n                    if (isDifferentValue(state, prevState, i, deep)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        else if (isArrayState || isArrayPrevState) {\r\n            return true;\r\n        }\r\n        else {\r\n            let key;\r\n            for (key in state) {\r\n                if (! (key in prevState) || isDifferentValue(state, prevState, key, deep)) {\r\n                    return true;\r\n                }\r\n            }\r\n            for (key in prevState) {\r\n                if (! (key in state)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    return state !== prevState;\r\n}\r\n\r\n/**\r\n * Check whether current object (state) is not equal previous object (state)\r\n * deeply comparing values of their fields.\r\n *\r\n * The same as `{@link module:listate/extra.unlike unlike}(state, prevState, true)`.\r\n *\r\n * @param {object} state\r\n *      A current object (state).\r\n * @param {object} prevState\r\n *      A previous object (state).\r\n * @return {boolean}\r\n *      `true` if current object is not equal previous object.\r\n * @see {@link module:listate/extra.unlike unlike}\r\n */\r\nexport function unlikeDeep(state, prevState) {\r\n    return unlike(state, prevState, true);\r\n}\r\n\r\n/**\r\n * Add/register state change listener for the given store.\r\n *\r\n * It is a wrap around {@link module:listate.listen listate.listen} that supports enhanced listener settings.\r\n *\r\n * @param {module:listate~Store} store\r\n *      Store for which listener should be added/registered.\r\n * @param {Function | object} listener\r\n *      Specifies listener that should be called on a state change.\r\n *      Can be a function or an object that defines listener settings/details.\r\n *      Settings are the same as for {@link module:listate.listate listate.listate} with the following exceptions.\r\n * @param {Array | Function | object | string} [listener.filter=(state) => state]\r\n *      Specifies which state part will be used inside `when` to determine\r\n *      whether the listener should be called.\r\n *      When an array or an object is passed, the used filter will be result of\r\n *      {@link module:listate/extra.getPartFilter getPartFilter(listener.filter)}.\r\n *      When a string is passed, the used filter will be result of\r\n *      {@link module:listate/extra.getFieldFilter getFieldFilter(listener.filter)}.\r\n * @param {Function} [listener.when=unlike]\r\n *      Function to determine whether the listener should be called.\r\n *      By default {@link module:listate/extra.unlike unlike} is used.\r\n * @return {Function}\r\n *      A function that removes/unsubscribes the listener.\r\n */\r\nexport default function listen(store, listener) {\r\n    let settings;\r\n    if (typeof listener === 'function') {\r\n        settings = {handle: listener};\r\n    }\r\n    else {\r\n        settings = {};\r\n        for (const key in listener) {\r\n            settings[key] = listener[key];\r\n        }\r\n    }\r\n    if (! settings.when) {\r\n        settings.when = unlike;\r\n    }\r\n    const { filter } = settings;\r\n    if (filter) {\r\n        const filterType = typeof filter;\r\n        if (filterType === 'object') {\r\n            settings.filter = getPartFilter(filter);\r\n        }\r\n        else if (filterType === 'string') {\r\n            settings.filter = getFieldFilter(filter);\r\n        }\r\n    }\r\n\r\n    return baseListen(store, settings);\r\n}\r\n\r\nexport { listen };\r\n"]}