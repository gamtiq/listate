<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"listate.js.html":{"id":"listate.js.html","title":"Source: listate.js","body":" listate Modules listatelistate/extra Source: listate.js /* * listate * https://github.com/gamtiq/listate * * Copyright (c) 2017 Denis Sikuler * Licensed under the MIT license. */ /* global clearTimeout, setTimeout */ /** * Library for listening on changes of Redux store state. * * @module listate */ /** * Store object. * * @typedef {Object} Store * * @property {Function} dispatch * Dispatches an action to trigger a state change. * @property {Function} getState * Returns the current state. * @property {Function} subscribe * Adds a change listener. */ /** * Parameter that is passed when calling the listener. * * @typedef {Object} HandleParam * * @property {any} current * The current state or a part of the current state if `filter` is set. * @property {any} data * The auxiliary data (value of `listener.data` parameter). * @property {Function} dispatch * Reference to `dispatch` method of the store. * @property {any} prev * The previous state or a part of the previous state if `filter` is set. * @property {object} prevState * The previous state. * @property {object} state * The current state. * @property {module:listate~Store} store * The store for which listener is registered. * @property {Function} unlisten * The function that removes/unsubscribes the listener. */ /** * Check whether current value (state) is not equal previous value (state). * * Uses `!==` for comparison. * * @param {object} state * A current value (state). * @param {object} prevState * A previous value (state). * @return {boolean} * `true` if current value is not equal previous value. */ export function baseWhen(state, prevState) { return state !== prevState; } // eslint-disable-next-line max-params, require-jsdoc function run(func, context, param, once) { return () =&gt; { func.call(context, param); if (once) { param.unlisten(); } }; } /** * Add/register state change listener for the given store. * * @example * import listen from 'listate'; * * const store = createStore(reducer, initState); * * listen(store, { * filter: (state) =&gt; state.section, * when: (current, prev) =&gt; current !== prev &amp;&amp; current !== 'exit', * delay: 1000, * handle: (data) =&gt; { * // data.current === state.section * localStorage.setItem('selectedSection', data.current); * } * }); * * @param {module:listate~Store} store * Store for which listener should be added/registered. * @param {Function | object} listener * Specifies listener that should be called on a state change. * Can be a function or an object that defines listener settings/details. * @param {Function} listener.handle * Listener that should be called on a state change. * @param {object} [listener.context] * Object that should be used as `this` value when calling the listener. * @param {any} [listener.data] * Any data that should be passed into the listener. * @param {number} [listener.delay] * Specifies that listener should be called after the given number of milliseconds have elapsed. * Works similar to `debounce`: when several requests for the listener call arrive during the specified period * only the last one will be applied after the timeout. * `0` is acceptable value that means the listener should be called asynchronuosly. * Negative number means that the listener should be called without delay. * @param {Function} [listener.filter=(state) =&gt; state] * Function (selector) to extract state part which will be used inside `when` to determine * whether the listener should be called. By default the entire state will be used. * @param {boolean} [listener.once=false] * Whether the listener should be called just once. * @param {Function} [listener.when=baseWhen] * Function to determine whether the listener should be called. * The listener will be called if the function returns true. * The following parameters will be passed into the function: * * * the current state or a part of the current state if `filter` is set. * * the previous state or a part of the previous state if `filter` is set. * * an object that will be passed into listener. * * @return {Function} * A function that removes/unsubscribes the listener. * @alias module:listate.listen */ export default function listen(store, listener) { const settings = typeof listener === 'function' ? {handle: listener} : listener; const { handle, data, filter, once } = settings; const context = settings.context || null; const delay = typeof settings.delay === 'number' ? settings.delay : -1; const when = settings.when || baseWhen; let prevState = store.getState(); let prev = filter ? filter(prevState) : prevState; let timeoutId; const unlisten = store.subscribe(() =&gt; { const state = store.getState(); const current = filter ? filter(state) : state; const param = { current, prev, state, prevState, data, store, dispatch: store.dispatch, unlisten }; prevState = state; if (when(current, prev, param) &amp;&amp; handle) { prev = current; if (delay &lt; 0) { handle.call(context, param); if (once) { unlisten(); } } else { clearTimeout(timeoutId); timeoutId = setTimeout(run(handle, context, param, once), delay); } } else { prev = current; } }); return unlisten; } export { listen }; × Search results Close "},"extra.js.html":{"id":"extra.js.html","title":"Source: extra.js","body":" listate Modules listatelistate/extra Source: extra.js /* * listate * https://github.com/gamtiq/listate * * Copyright (c) 2017 Denis Sikuler * Licensed under the MIT license. */ /** * Library for listening on changes of Redux store state. * * @module listate/extra */ import baseListen from './listate'; /** * Return value of specified field path inside given object. * * @example * const obj = { * a: { * b: { * c: 'value' * }, * d: true * }, * e: 4, * f: [1, 'z', null] * }; * * getPathValue(obj, 'a.b.c'); // 'value' * getPathValue(obj, 'a.d'); // true * getPathValue(obj, 'e'); // 4 * getPathValue(obj, 'f.1'); // 'z' * getPathValue(obj, 'g'); // undefined * getPathValue(obj, 'a.c'); // undefined * getPathValue(obj, 'e.a'); // undefined * getPathValue(obj, 'f.8'); // undefined * * @param {object} obj * The object to traverse. * @param {string} path * Dot-delimited path to a field whose value should be returned. * @return {any} * Value of the field or `undefined` when the field is not found inside the object. */ export function getPathValue(obj, path) { const field = path.split('.'); const len = field.length; let i = 0; let value = obj; let undef; while (i &lt; len &amp;&amp; value &amp;&amp; typeof value === 'object') { value = value[field[i++]]; } return i &lt; len ? undef : value; } /** * Create an object containing specified parts of the given object. * * @example * const obj = { * a: { * b: { * c: 'value', * d: true * }, * e: 4, * f: [1, 'z', null] * }, * g: 7, * h: { * i: false, * j: 0 * }, * k: 'king', * l: 'last' * }; * * getObjectPart(obj, {f1: 'a.b.d', f2: 'a.f.1', f3: 'g', f4: 'h.j'}); // {f1: true, f2: 'z', f3: 7, f4: 0} * getObjectPart(obj, ['k', 'l']); // {k: 'king', l: 'last'} * getObjectPart(obj, 'g'); // {g: 7} * * @param {object} source * A source object that should be processed. * @param {array | object | string} parts * Specifies which parts of the source object should be extracted. * Parts are described as an object of the following form: * `{resultField1: 'path.to.source.part1', resultField2: 'path.to.part2', ...}`. * Each field of the object is a property name of resulting object * whose value is the value of specified source object part. * String value `'field'` is equal to `{field: 'field'}`. * Array value `['a', 'b', 'c', ...]` is equal to `{a: 'a', b: 'b', c: 'c', ...}`. * @return {object} * Object that contains the extracted parts of the source object. * @see {@link module:listate/extra.getPathValue getPathValue} */ export function getObjectPart(source, parts) { let partMap; if (typeof parts === 'string') { partMap = {[parts]: parts}; } else if (Array.isArray(parts)) { partMap = {}; for (let i = 0, len = parts.length; i &lt; len; i++) { partMap[parts[i]] = parts[i]; } } else { partMap = parts; } const result = {}; for (const key in partMap) { result[key] = getPathValue(source, partMap[key]); } return result; } /** * Return a function that extracts value of the specified field path inside a given object. * * @example * const filter = getFieldFilter('a.d'); * * const obj = { * a: { * b: { * c: 'value' * }, * d: 17 * }, * e: 4, * f: [1, 'z', null] * }; * * filter(obj); // 17 * filter({a: 1, b: 2}); // undefined * * @param {string} path * Dot-delimited path to a field whose value should be extracted. * @return {Function} * A function that extracts value of the specified field path inside a given object. * @see {@link module:listate/extra.getPathValue getPathValue} */ export function getFieldFilter(path) { return (obj) =&gt; getPathValue(obj, path); } /** * Return a function that creates an object containing the specified parts of a given object. * * @example * const filter = getPartFilter({f1: 'a.b.c', f2: 'h.j', f3: 'k'}); * * const obj = { * a: { * b: { * c: 'value', * d: true * }, * e: 4, * f: [1, 'z', null] * }, * g: 7, * h: { * i: false, * j: 0 * }, * k: 'king', * l: 'last' * }; * * filter(obj); // {f1: 'value', f2: 0, f3: 'king'} * filter({a: 1, b: 2, k: 73}); // {f1: undefined, f2: undefined, f3: 73} * * @param {array | object | string} parts * Specifies which parts should be extracted (see {@link module:listate/extra.getObjectPart getObjectPart}). * @return {Function} * A function that creates an object containing the specified parts of a given object. * @see {@link module:listate/extra.getObjectPart getObjectPart} */ export function getPartFilter(parts) { return (obj) =&gt; getObjectPart(obj, parts); } // eslint-disable-next-line max-params, require-jsdoc function isDifferentValue(state, prevState, field, deep) { const value = state[field]; const prevValue = prevState[field]; return value !== prevValue &amp;&amp; (! deep || unlike(value, prevValue, deep)); // eslint-disable-line no-use-before-define } /** * Check whether current object (state) is not equal previous object (state) * comparing values of their fields. * * @example * unlike({a: 1}, {a: 2}); // true * unlike({a: 1, b: 2}, {a: 1}); // true * unlike({a: 1, b: 2}, {a: 1, b: 2}); // false * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}); // true * unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}, true); // false * * @param {object} state * A current object (state). * @param {object} prevState * A previous object (state). * @param {boolean} [deep=false] * When `true` recursively calls the function to compare fields having object values. * By default shallow equality comparison (`!==`) is used. * @return {boolean} * `true` if current object is not equal previous object. */ export function unlike(state, prevState, deep) { if (state &amp;&amp; prevState &amp;&amp; typeof state === 'object' &amp;&amp; typeof prevState === 'object') { const isArrayState = Array.isArray(state); const isArrayPrevState = Array.isArray(prevState); if (isArrayState &amp;&amp; isArrayPrevState) { const len = state.length; if (len === prevState.length) { for (let i = 0; i &lt; len; i++) { if (isDifferentValue(state, prevState, i, deep)) { return true; } } } else { return true; } } else if (isArrayState || isArrayPrevState) { return true; } else { let key; for (key in state) { if (! (key in prevState) || isDifferentValue(state, prevState, key, deep)) { return true; } } for (key in prevState) { if (! (key in state)) { return true; } } } return false; } return state !== prevState; } /** * Check whether current object (state) is not equal previous object (state) * deeply comparing values of their fields. * * The same as `{@link module:listate/extra.unlike unlike}(state, prevState, true)`. * * @param {object} state * A current object (state). * @param {object} prevState * A previous object (state). * @return {boolean} * `true` if current object is not equal previous object. * @see {@link module:listate/extra.unlike unlike} */ export function unlikeDeep(state, prevState) { return unlike(state, prevState, true); } /** * Add/register state change listener for the given store. * * It is a wrap around {@link module:listate.listen listate.listen} that supports enhanced listener settings. * * @param {module:listate~Store} store * Store for which listener should be added/registered. * @param {Function | object} listener * Specifies listener that should be called on a state change. * Can be a function or an object that defines listener settings/details. * Settings are the same as for {@link module:listate.listate listate.listate} with the following exceptions. * @param {Array | Function | object | string} [listener.filter=(state) =&gt; state] * Specifies which state part will be used inside `when` to determine * whether the listener should be called. * When an array or an object is passed, the used filter will be result of * {@link module:listate/extra.getPartFilter getPartFilter(listener.filter)}. * When a string is passed, the used filter will be result of * {@link module:listate/extra.getFieldFilter getFieldFilter(listener.filter)}. * @param {Function} [listener.when=unlike] * Function to determine whether the listener should be called. * By default {@link module:listate/extra.unlike unlike} is used. * @return {Function} * A function that removes/unsubscribes the listener. */ export default function listen(store, listener) { let settings; if (typeof listener === 'function') { settings = {handle: listener}; } else { settings = {}; for (const key in listener) { settings[key] = listener[key]; } } if (! settings.when) { settings.when = unlike; } const { filter } = settings; if (filter) { const filterType = typeof filter; if (filterType === 'object') { settings.filter = getPartFilter(filter); } else if (filterType === 'string') { settings.filter = getFieldFilter(filter); } } return baseListen(store, settings); } export { listen }; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" listate Modules listatelistate/extra Modules × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" listate Modules listatelistate/extra listate Library to listen/observe/watch changes of Redux store state. Table of contents Installation Usage Examples API Contributing License Installation ↑Nodenpm install listateBowerbower install listateAMD, &lt;script&gt;Use dist/listate.js or dist/listate.min.js (minified version). Use dist/extra.js or dist/extra.min.js (minified version) to apply extra functions. Usage ↑ECMAScript 6import listen from 'listate'; // Or if you need extra functionality import extListen from 'listate/extra';Nodeconst listen = require('listate').listen; // Or if you need extra functionality const extListen = require('listate/extra').listen;Duoconst listen = require('gamtiq/listate').listen; // Or if you need extra functionality const extListen = require('gamtiq/listate/extra').listen;AMDdefine(['path/to/dist/listate.js', 'path/to/dist/extra.js'], function(listate, extra) { const listen = listate.listen; // Import extra.js if you need extra functionality const extListen = extra.listen; });Bower, &lt;script&gt;&lt;!-- Use bower_components/listate/dist/listate.js and bower_components/listate/dist/extra.js if the library was installed by Bower --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/dist/listate.js&quot;&gt;&lt;/script&gt; &lt;!-- Or if you need extra functionality --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;path/to/dist/extra.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; // listate is available via listate field of window object const listen = listate.listen; // Extra functionality is available inside extra namespace const extListen = listate.extra.listen; &lt;/script&gt;Examples ↑import { createStore } from 'redux'; import listen from 'listate'; import extListen from 'listate/extra'; const initState = { user: null, section: '', map: { main: {} } }; function reducer(state, action) { const { payload } = action; let newState; switch (action.type) { case 'AUTH': return Object.assign({}, state, {user: payload}); case 'SELECT_SECTION': return Object.assign({}, state, {section: payload}); case 'SET_SECTION': newState = Object.assign({}, state); newState.map = Object.assign({}, state.map); newState.map[payload.key] = payload.value; return newState; default: return state; } } const store = createStore(reducer, initState); listen(store, { data: 'main', filter: (state) =&gt; state.user, // One-time listener once: true, handle: (data) =&gt; { // Dispatch any action data.dispatch({ type: 'SELECT_SECTION', // data.current === state.user, data.data === 'main' payload: data.current.favoriteSection || localStorage.getItem('selectedSection') || data.data }); } }); listen(store, { filter: (state) =&gt; state.section, when: (current, prev) =&gt; current !== prev &amp;&amp; current !== 'exit', // Call the listener no more frequently than once per second delay: 1000, handle: (data) =&gt; { // data.current === state.section localStorage.setItem('selectedSection', data.current); console.log('Saved section: ', data.current); } }); listen(store, { filter: (state) =&gt; state.map, when: (current, prev, data) =&gt; current.stat &amp;&amp; data.state.user &amp;&amp; data.state.section === 'video', handle: (data) =&gt; { console.log('data.prev:', data.prev); // {main: {}} console.log('data.current:', data.current); // {main: {}, stat: {a: 1}} } }); extListen(store, { filter: {s: 'section', main: 'map.main'}, handle: (data) =&gt; { console.log('extListen: data.prev -', data.prev); console.log('extListen: data.current -', data.current); } }); ... store.dispatch({ type: 'AUTH', payload: {login: 'commander'} }); ... store.dispatch({ type: 'SELECT_SECTION', payload: 'video' }); ... store.dispatch({ type: 'SET_SECTION', payload: { key: 'stat', value: { a: 1 } } }); ... store.dispatch({ type: 'SELECT_SECTION', payload: 'news' }); ... store.dispatch({ type: 'SET_SECTION', payload: { key: 'main', value: { content: 'text' } } });API ↑Base functionality (listate, dist/listate.js)baseWhen(state, prevState): booleanChecks whether current value (state) is not equal previous value (state). Returns value of the following comparison: state !== prevState. listen(store, listener): FunctionAdds/registers state change listener for the given store. Arguments: store: object - Store for which listener should be added/registered. listener: Function | object - Specifies listener that should be called on a state change. Can be a function or an object that defines listener settings/details. listener.handle: Function - Listener that should be called on a state change. listener.context: object (optional) - Object that should be used as this value when calling the listener. listener.data: any (optional) - Any data that should be passed into the listener. listener.delay: number (optional) - Specifies that listener should be called after the given number of milliseconds have elapsed. Works similar to debounce: when several requests for the listener call arrive during the specified period only the last one will be applied after the timeout. listener.filter: (state) =&gt; state.part (optional) - Function (selector) to extract state part which will be used inside when to determine whether the listener should be called. By default the entire state will be used. listener.once: boolean (optional) - Whether the listener should be called just once (by default false). listener.when: (current, prev, data) =&gt; boolean (optional) - Function to determine whether the listener should be called. By default baseWhen is used. The listener will be called if the function returns true. The following parameters will be passed into the function: The current state or a part of the current state if filter is set. The previous state or a part of the previous state if filter is set. An object that will be passed into listener. Returns a function that removes/unsubscribes the listener. An object with the following fileds will be passed as parameter into the listener: current: any - The current state or a part of the current state if filter is set. prev: any - The previous state or a part of the previous state if filter is set. state: object - The current state. prevState: object - The previous state. data: any - The auxiliary data (value of listener.data parameter). store: object - The store for which listener is registered. dispatch: Function - Reference to dispatch method of the store. unlisten: Function - The function that removes/unsubscribes the listener. Extra functionality (listate/extra, dist/extra.js)getPathValue(obj, path): anyReturn value of specified field path inside given object. import { getPathValue } from 'listate/extra'; const obj = { a: { b: { c: 'value' }, d: true }, e: 4, f: [1, 'z', null] }; getPathValue(obj, 'a.b.c'); // 'value' getPathValue(obj, 'a.c'); // undefinedgetObjectPart(source, parts): objectCreate an object containing specified parts of the given object. import { getObjectPart } from 'listate/extra'; const obj = { a: { b: { c: 'value', d: true }, e: 4, f: [1, 'z', null] }, g: 7, h: { i: false, j: 0 }, k: 'king', l: 'last' }; getObjectPart(obj, {f1: 'a.b.d', f2: 'a.f.1', f3: 'g', f4: 'h.j'}); // {f1: true, f2: 'z', f3: 7, f4: 0}getFieldFilter(path): FunctionReturn a function that extracts value of the specified field path inside a given object. import { getFieldFilter } from 'listate/extra'; const filter = getFieldFilter('a.d'); const obj = { a: { b: { c: 'value' }, d: 17 }, e: 4, f: [1, 'z', null] }; filter(obj); // 17getPartFilter(parts): FunctionReturn a function that creates an object containing the specified parts of a given object. import { getPartFilter } from 'listate/extra'; const filter = getPartFilter({f1: 'a.b.c', f2: 'h.j', f3: 'k'}); const obj = { a: { b: { c: 'value', d: true }, e: 4, f: [1, 'z', null] }, g: 7, h: { i: false, j: 0 }, k: 'king', l: 'last' }; filter(obj); // {f1: 'value', f2: 0, f3: 'king'}unlike(state, prevState, deep): booleanCheck whether current object (state) is not equal previous object (state) comparing values of their fields. import { unlike } from 'listate/extra'; unlike({a: 1, b: 2}, {a: 1, b: 2}); // false unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}); // true unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}, true); // falseunlikeDeep(state, prevState): booleanCheck whether current object (state) is not equal previous object (state) deeply comparing values of their fields. The same as unlike(state, prevState, true). listen(store, listener): FunctionAdd/register state change listener for the given store. It is a wrap around base listate.listen that supports the following enhanced listener settings: listener.filter. When an array or an object is passed, the used filter will be result of getPartFilter(listener.filter). When a string is passed, the used filter will be result of getFieldFilter(listener.filter). listener.when. By default unlike is used. See doc folder for details. Contributing ↑In lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code. License ↑Copyright (c) 2017 Denis SikulerLicensed under the MIT license. × Search results Close "},"module-listate.html":{"id":"module-listate.html","title":"Module: listate","body":" listate Modules listatelistate/extra Module: listate Library for listening on changes of Redux store state. Source: listate.js, line 11 Methods &lt;static&gt; baseWhen(state, prevState) Check whether current value (state) is not equal previous value (state). Uses !== for comparison. Parameters: Name Type Description state object A current value (state). prevState object A previous value (state). Source: listate.js, line 65 Returns: true if current value is not equal previous value. Type boolean &lt;static&gt; listen(store, listener) Add/register state change listener for the given store. Parameters: Name Type Description store module:listate~Store Store for which listener should be added/registered. listener function | object Specifies listener that should be called on a state change. Can be a function or an object that defines listener settings/details. Properties Name Type Argument Default Description handle function Listener that should be called on a state change. context object &lt;optional&gt; Object that should be used as this value when calling the listener. data any &lt;optional&gt; Any data that should be passed into the listener. delay number &lt;optional&gt; Specifies that listener should be called after the given number of milliseconds have elapsed. Works similar to debounce: when several requests for the listener call arrive during the specified period only the last one will be applied after the timeout. 0 is acceptable value that means the listener should be called asynchronuosly. Negative number means that the listener should be called without delay. filter function &lt;optional&gt; (state) =&gt; state Function (selector) to extract state part which will be used inside when to determine whether the listener should be called. By default the entire state will be used. once boolean &lt;optional&gt; false Whether the listener should be called just once. when function &lt;optional&gt; baseWhen Function to determine whether the listener should be called. The listener will be called if the function returns true. The following parameters will be passed into the function: the current state or a part of the current state if filter is set. the previous state or a part of the previous state if filter is set. an object that will be passed into listener. Source: listate.js, line 132 Returns: A function that removes/unsubscribes the listener. Type function Example import listen from 'listate'; const store = createStore(reducer, initState); listen(store, { filter: (state) =&gt; state.section, when: (current, prev) =&gt; current !== prev &amp;&amp; current !== 'exit', delay: 1000, handle: (data) =&gt; { // data.current === state.section localStorage.setItem('selectedSection', data.current); } }); Type Definitions HandleParam Parameter that is passed when calling the listener. Type: Object Properties: Name Type Description current any The current state or a part of the current state if filter is set. data any The auxiliary data (value of listener.data parameter). dispatch function Reference to dispatch method of the store. prev any The previous state or a part of the previous state if filter is set. prevState object The previous state. state object The current state. store module:listate~Store The store for which listener is registered. unlisten function The function that removes/unsubscribes the listener. Source: listate.js, line 30 Store Store object. Type: Object Properties: Name Type Description dispatch function Dispatches an action to trigger a state change. getState function Returns the current state. subscribe function Adds a change listener. Source: listate.js, line 17 × Search results Close "},"module-listate_extra.html":{"id":"module-listate_extra.html","title":"Module: listate/extra","body":" listate Modules listatelistate/extra Module: listate/extra Library for listening on changes of Redux store state. (require(&quot;listate/extra&quot;))(store, listener) Add/register state change listener for the given store. It is a wrap around listate.listen that supports enhanced listener settings. Parameters: Name Type Description store module:listate~Store Store for which listener should be added/registered. listener function | object Specifies listener that should be called on a state change. Can be a function or an object that defines listener settings/details. Settings are the same as for listate.listate with the following exceptions. Properties Name Type Argument Default Description filter Array | function | object | string &lt;optional&gt; (state) =&gt; state Specifies which state part will be used inside when to determine whether the listener should be called. When an array or an object is passed, the used filter will be result of getPartFilter(listener.filter). When a string is passed, the used filter will be result of getFieldFilter(listener.filter). when function &lt;optional&gt; unlike Function to determine whether the listener should be called. By default unlike is used. Source: extra.js, line 305 Returns: A function that removes/unsubscribes the listener. Type function Methods &lt;static&gt; getFieldFilter(path) Return a function that extracts value of the specified field path inside a given object. Parameters: Name Type Description path string Dot-delimited path to a field whose value should be extracted. Source: extra.js, line 152 See: getPathValue Returns: A function that extracts value of the specified field path inside a given object. Type function Example const filter = getFieldFilter('a.d'); const obj = { a: { b: { c: 'value' }, d: 17 }, e: 4, f: [1, 'z', null] }; filter(obj); // 17 filter({a: 1, b: 2}); // undefined &lt;static&gt; getObjectPart(source, parts) Create an object containing specified parts of the given object. Parameters: Name Type Description source object A source object that should be processed. parts array | object | string Specifies which parts of the source object should be extracted. Parts are described as an object of the following form: {resultField1: 'path.to.source.part1', resultField2: 'path.to.part2', ...}. Each field of the object is a property name of resulting object whose value is the value of specified source object part. String value 'field' is equal to {field: 'field'}. Array value ['a', 'b', 'c', ...] is equal to {a: 'a', b: 'b', c: 'c', ...}. Source: extra.js, line 103 See: getPathValue Returns: Object that contains the extracted parts of the source object. Type object Example const obj = { a: { b: { c: 'value', d: true }, e: 4, f: [1, 'z', null] }, g: 7, h: { i: false, j: 0 }, k: 'king', l: 'last' }; getObjectPart(obj, {f1: 'a.b.d', f2: 'a.f.1', f3: 'g', f4: 'h.j'}); // {f1: true, f2: 'z', f3: 7, f4: 0} getObjectPart(obj, ['k', 'l']); // {k: 'king', l: 'last'} getObjectPart(obj, 'g'); // {g: 7} &lt;static&gt; getPartFilter(parts) Return a function that creates an object containing the specified parts of a given object. Parameters: Name Type Description parts array | object | string Specifies which parts should be extracted (see getObjectPart). Source: extra.js, line 189 See: getObjectPart Returns: A function that creates an object containing the specified parts of a given object. Type function Example const filter = getPartFilter({f1: 'a.b.c', f2: 'h.j', f3: 'k'}); const obj = { a: { b: { c: 'value', d: true }, e: 4, f: [1, 'z', null] }, g: 7, h: { i: false, j: 0 }, k: 'king', l: 'last' }; filter(obj); // {f1: 'value', f2: 0, f3: 'king'} filter({a: 1, b: 2, k: 73}); // {f1: undefined, f2: undefined, f3: 73} &lt;static&gt; getPathValue(obj, path) Return value of specified field path inside given object. Parameters: Name Type Description obj object The object to traverse. path string Dot-delimited path to a field whose value should be returned. Source: extra.js, line 48 Returns: Value of the field or undefined when the field is not found inside the object. Type any Example const obj = { a: { b: { c: 'value' }, d: true }, e: 4, f: [1, 'z', null] }; getPathValue(obj, 'a.b.c'); // 'value' getPathValue(obj, 'a.d'); // true getPathValue(obj, 'e'); // 4 getPathValue(obj, 'f.1'); // 'z' getPathValue(obj, 'g'); // undefined getPathValue(obj, 'a.c'); // undefined getPathValue(obj, 'e.a'); // undefined getPathValue(obj, 'f.8'); // undefined &lt;static&gt; unlike(state, prevState [, deep]) Check whether current object (state) is not equal previous object (state) comparing values of their fields. Parameters: Name Type Argument Default Description state object A current object (state). prevState object A previous object (state). deep boolean &lt;optional&gt; false When true recursively calls the function to compare fields having object values. By default shallow equality comparison (!==) is used. Source: extra.js, line 223 Returns: true if current object is not equal previous object. Type boolean Example unlike({a: 1}, {a: 2}); // true unlike({a: 1, b: 2}, {a: 1}); // true unlike({a: 1, b: 2}, {a: 1, b: 2}); // false unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}); // true unlike({a: 1, b: {c: 3}}, {a: 1, b: {c: 3}}, true); // false &lt;static&gt; unlikeDeep(state, prevState) Check whether current object (state) is not equal previous object (state) deeply comparing values of their fields. The same as unlike(state, prevState, true). Parameters: Name Type Description state object A current object (state). prevState object A previous object (state). Source: extra.js, line 277 See: unlike Returns: true if current object is not equal previous object. Type boolean × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
